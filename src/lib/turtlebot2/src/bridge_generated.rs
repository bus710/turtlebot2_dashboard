#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    non_snake_case
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`.

use crate::api::*;
use flutter_rust_bridge::*;

// Section: wire functions

#[no_mangle]
pub extern "C" fn wire_spawn_turtlebot(port_: i64) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "spawn_turtlebot",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || move |task_callback| spawn_turtlebot(task_callback.stream_sink()),
    )
}

#[no_mangle]
pub extern "C" fn wire_receive_from_turtlebot(port_: i64) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "receive_from_turtlebot",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| receive_from_turtlebot(),
    )
}

#[no_mangle]
pub extern "C" fn wire_search_port_command(port_: i64) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "search_port_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| search_port_command(),
    )
}

#[no_mangle]
pub extern "C" fn wire_open_port_command(port_: i64, serial_port: *mut wire_uint_8_list) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "open_port_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_serial_port = serial_port.wire2api();
            move |task_callback| open_port_command(api_serial_port)
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_close_port_command(port_: i64) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "close_port_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| close_port_command(),
    )
}

#[no_mangle]
pub extern "C" fn wire_base_control_command(port_: i64, speed: u16, radius: u16) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "base_control_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_speed = speed.wire2api();
            let api_radius = radius.wire2api();
            move |task_callback| base_control_command(api_speed, api_radius)
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_sound_command(port_: i64, freq: u8, amp: u8, duration: u8) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sound_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_freq = freq.wire2api();
            let api_amp = amp.wire2api();
            let api_duration = duration.wire2api();
            move |task_callback| sound_command(api_freq, api_amp, api_duration)
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_sound_sequence_command(port_: i64, seq: u8) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sound_sequence_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_seq = seq.wire2api();
            move |task_callback| sound_sequence_command(api_seq)
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_request_extra_command(port_: i64, hw_ver: bool, fw_ver: bool, udid: bool) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "request_extra_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_hw_ver = hw_ver.wire2api();
            let api_fw_ver = fw_ver.wire2api();
            let api_udid = udid.wire2api();
            move |task_callback| request_extra_command(api_hw_ver, api_fw_ver, api_udid)
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_general_purpose_output_command(
    port_: i64,
    d_out_ch0: bool,
    d_out_ch1: bool,
    d_out_ch2: bool,
    d_out_ch3: bool,
    power_3v3: bool,
    power_5v0: bool,
    power_12v5a: bool,
    power_12v1a5: bool,
    red_led1: bool,
    red_led2: bool,
    green_led1: bool,
    green_led2: bool,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "general_purpose_output_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_d_out_ch0 = d_out_ch0.wire2api();
            let api_d_out_ch1 = d_out_ch1.wire2api();
            let api_d_out_ch2 = d_out_ch2.wire2api();
            let api_d_out_ch3 = d_out_ch3.wire2api();
            let api_power_3v3 = power_3v3.wire2api();
            let api_power_5v0 = power_5v0.wire2api();
            let api_power_12v5a = power_12v5a.wire2api();
            let api_power_12v1a5 = power_12v1a5.wire2api();
            let api_red_led1 = red_led1.wire2api();
            let api_red_led2 = red_led2.wire2api();
            let api_green_led1 = green_led1.wire2api();
            let api_green_led2 = green_led2.wire2api();
            move |task_callback| {
                general_purpose_output_command(
                    api_d_out_ch0,
                    api_d_out_ch1,
                    api_d_out_ch2,
                    api_d_out_ch3,
                    api_power_3v3,
                    api_power_5v0,
                    api_power_12v5a,
                    api_power_12v1a5,
                    api_red_led1,
                    api_red_led2,
                    api_green_led1,
                    api_green_led2,
                )
            }
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_set_controller_gain_command(
    port_: i64,
    is_user_configured: bool,
    p: u32,
    i: f32,
    d: u32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_controller_gain_command",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_is_user_configured = is_user_configured.wire2api();
            let api_p = p.wire2api();
            let api_i = i.wire2api();
            let api_d = d.wire2api();
            move |task_callback| {
                set_controller_gain_command(api_is_user_configured, api_p, api_i, api_d)
            }
        },
    )
}

#[no_mangle]
pub extern "C" fn wire_get_controller_gain(port_: i64) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_controller_gain",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| get_controller_gain(),
    )
}

// Section: wire structs

#[repr(C)]
#[derive(Clone)]
pub struct wire_uint_8_list {
    ptr: *mut u8,
    len: i32,
}

// Section: wire enums

// Section: allocate functions

#[no_mangle]
pub extern "C" fn new_uint_8_list(len: i32) -> *mut wire_uint_8_list {
    let ans = wire_uint_8_list {
        ptr: support::new_leak_vec_ptr(Default::default(), len),
        len,
    };
    support::new_leak_box_ptr(ans)
}

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        if self.is_null() {
            None
        } else {
            Some(self.wire2api())
        }
    }
}

impl Wire2Api<String> for *mut wire_uint_8_list {
    fn wire2api(self) -> String {
        let vec: Vec<u8> = self.wire2api();
        String::from_utf8_lossy(&vec).into_owned()
    }
}

impl Wire2Api<bool> for bool {
    fn wire2api(self) -> bool {
        self
    }
}

impl Wire2Api<f32> for f32 {
    fn wire2api(self) -> f32 {
        self
    }
}

impl Wire2Api<u16> for u16 {
    fn wire2api(self) -> u16 {
        self
    }
}

impl Wire2Api<u32> for u32 {
    fn wire2api(self) -> u32 {
        self
    }
}

impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<Vec<u8>> for *mut wire_uint_8_list {
    fn wire2api(self) -> Vec<u8> {
        unsafe {
            let wrap = support::box_from_leak_ptr(self);
            support::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}

// Section: impl NewWithNullPtr

pub trait NewWithNullPtr {
    fn new_with_null_ptr() -> Self;
}

impl<T> NewWithNullPtr for *mut T {
    fn new_with_null_ptr() -> Self {
        std::ptr::null_mut()
    }
}

// Section: impl IntoDart

impl support::IntoDart for BasicSensor {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.time_stamp.into_dart(),
            self.bumper.into_dart(),
            self.wheel_drop.into_dart(),
            self.cliff.into_dart(),
            self.left_encoder.into_dart(),
            self.right_encoder.into_dart(),
            self.left_pwm.into_dart(),
            self.right_pwm.into_dart(),
            self.button.into_dart(),
            self.charger.into_dart(),
            self.battery.into_dart(),
            self.overcurrent_flags.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BasicSensor {}

impl support::IntoDart for Cliff {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.right_cliff_sensor.into_dart(),
            self.central_cliff_sensor.into_dart(),
            self.left_cliff_sensor.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Cliff {}

impl support::IntoDart for ControllerInfo {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.is_user_configured.into_dart(),
            self.p_gain.into_dart(),
            self.i_gain.into_dart(),
            self.d_gain.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for ControllerInfo {}

impl support::IntoDart for Current {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.left_motor.into_dart(),
            self.right_motor.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Current {}

impl support::IntoDart for DockingIR {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.right_signal.into_dart(),
            self.central_signal.into_dart(),
            self.left_signal.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for DockingIR {}

impl support::IntoDart for Feedback {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.epoch_time_stamp.into_dart(),
            self.basic_sensor.into_dart(),
            self.docking_ir.into_dart(),
            self.inertial_sensor.into_dart(),
            self.cliff.into_dart(),
            self.current.into_dart(),
            self.hardware_version.into_dart(),
            self.firmware_version.into_dart(),
            self.gyro.into_dart(),
            self.general_purpose_input.into_dart(),
            self.unique_device_id.into_dart(),
            self.controller_info.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Feedback {}

impl support::IntoDart for FirmwareVersion {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.patch.into_dart(),
            self.minor.into_dart(),
            self.major.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for FirmwareVersion {}

impl support::IntoDart for GeneralPurposeInput {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.d_ch0.into_dart(),
            self.a_ch0.into_dart(),
            self.a_ch1.into_dart(),
            self.a_ch2.into_dart(),
            self.a_ch3.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for GeneralPurposeInput {}

impl support::IntoDart for Gyro {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.frame_id.into_dart(),
            self.followed_data_length.into_dart(),
            self.x0.into_dart(),
            self.y0.into_dart(),
            self.z0.into_dart(),
            self.x1.into_dart(),
            self.y1.into_dart(),
            self.z1.into_dart(),
            self.x2.into_dart(),
            self.y2.into_dart(),
            self.z2.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Gyro {}

impl support::IntoDart for HardwareVersion {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.patch.into_dart(),
            self.minor.into_dart(),
            self.major.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for HardwareVersion {}

impl support::IntoDart for InertialSensor {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.angle.into_dart(),
            self.angle_rate.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for InertialSensor {}

impl support::IntoDart for UniqueDeviceId {
    fn into_dart(self) -> support::DartCObject {
        vec![
            self.valid.into_dart(),
            self.udid0.into_dart(),
            self.udid1.into_dart(),
            self.udid2.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for UniqueDeviceId {}

// Section: executor
support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

// Section: sync execution mode utility

#[no_mangle]
pub extern "C" fn free_WireSyncReturnStruct(val: support::WireSyncReturnStruct) {
    unsafe {
        let _ = support::vec_from_leak_ptr(val.ptr, val.len);
    }
}
